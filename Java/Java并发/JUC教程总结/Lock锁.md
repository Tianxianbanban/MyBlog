## 锁



### **Lock接口**

+ 关于Lock

  + 首先锁是一种工具，用于控制对**共享资源**的访问。**Lock和synchronized**是两个最常见的锁，都可以达到**线程安全**的目的，但是在使用上和功能上又有较大的不同。其中**Lock并不是来替代synchronized的**，而是当使用synchronized不合适或者不足以满足需求的时候，就可以使用Lock来提供**高级功能**。
  + Lock接口最常见的实现类就是**ReentrantLock**。通常情况下，Lock只允许一个线程来访问共享资源，但是有的时候，一些特殊实现可以允许并发访问，比如ReadWriteLock里面的ReadLock。
  
+ 为什么Synchronized使用还不够，Lock的使用有什么优势？

  + 效率低：锁的释放情况少、试图获取锁时不能设定超时、不能中断正在试图获得锁的线程。
  + 不够灵活：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象）。相比而言读写锁就更灵活。

  + 无法知道是否成功获取到锁。

+ Lock的方法

  Lock当中获取锁的四个方法lock()、tryLock()、tryLock(long time，TimeUnit unit)、lockInterruptibly()

  + lock()
    + lock方法就是最普通的获取锁。如果锁已经被其他的线程获取，就进行等待。
    + Lock不会像synchronized一样在异常的时候自动释放锁，所以使用lock方法的时候，最好是**在finally当中释放锁**，以保证发生异常时锁一定会被释放。
    + lock方法不能被中断，就带来了很大的隐患：一旦陷入死锁，lock()就会陷入永久等待。但是使用tryLock方法可以解决这个问题。
  + tryLock()
    + tryLock方法用来**尝试获取锁**，如果当前锁没有被其他线程占用，则获取成功返回true，否则返回false代表获取锁失败。所以相比于lock方法，tryLock方法显然更强大些，使用时**就可以根据是否能够获取到锁来决定后续程序行为**了。
    + 这个方法会**立即返回**，即便在拿不到锁的情况下也不会一直在哪儿等。
  + tryLock(long time，TimeUnit unit)
    + 超时就放弃，这个特点也有效预防了死锁。
  + lockInterruptibly()：相当于tryLock(long time，TimeUnit unit)把超时时间设置为无限，**在等待锁的过程中，线程可以被中断**。
  + unlock()：解锁。一定要记得解锁，应该在finally当中调用更合适。

+ **可见性**保证

  + happens-before
  + Lock的加解锁和synchronized有同样的**内存语义**，也就是说，**下一个线程加锁后可以看到所有前一个线程解锁前发生的所有操作**。所以Lock是有可见性保证的。





****

### **锁的分类**

关于锁的分类，是**从各种不同角度去看的**。这些分类并**不是互斥**的，也就是多个类型可以并存，有可能一个锁同时属于两种类型，比如ReentrantLock即是互斥锁，又是可重入锁。



**乐观锁和悲观锁**

+ 为什么会诞生（乐观锁）非互斥同步锁以及（悲观锁）互斥同步锁的劣势

  关于（悲观锁）互斥同步锁的劣势：

  + **阻塞和唤醒带来的性能劣势**。悲观锁锁住以后就是独占的，其它线程想获得相同的资源就必须等待，这带来的最大问题就是阻塞和唤醒阶段的性能问题。包括一系列操作，比如用户态核心态的切换、上下文切换、检查是否有被阻塞线程需要被唤醒等等，这会消耗大量的系统资源，是很大的性能损耗。所以**乐观锁主要解决的就是这个性能问题，乐观锁不需要把线程挂起**。

  + 可能陷入**永久阻塞**。如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个线程，将永远得不到执行。
+ **优先级反转**。如果被阻塞的线程优先级较高，而持有锁的线程优先级较低，就会导致优先级反转。这样，即使使用时给线程设置了不同的优先级，也会因为互斥同步锁的使用而出现优先级错乱的情况。
  
+ 什么是乐观锁与悲观锁

  **悲观锁**：如果我不锁住这个资源，别人就会来抢，会造成数据结果错误，所以每次悲观锁为了**确保据结果的正确性，会在每次获取并且修改数据时把数据锁住**，让别人无法访问该数据，以确保数据内容万无一失。

  Java当中悲观锁的实现就是**synchronized和Lock相关类**。当然，synchronized经过优化后前面会有一些乐观的过程。

  **乐观锁**：认为自己处理操作时不会有其他线程来干扰，所以并不会锁住被操作对象。在更新的时候，去**对比在修改的期间数据有没有被其他人改变过**，如果没被改变过，就说明真的只是自己在操作，那么就可以正常去修改数据。如果数据和我一开始拿到的不一样，说明其他线程在这段时间内修改过数据，那就不能继续刚才的更新数据操作了，会选择放弃、报错、重试等策略。

  乐观锁的实现一般都是利用**CAS**算法来实现的。CAS的核心思想就是可以在一个**原子操作**内把数据进行对比和交换。

+ 典型例子

  悲观锁：synchronized和Lock接口

  乐观锁：原子类、许多并发容器等都用到了乐观锁的思想。

  比如Git提交是一种乐观锁的体现，而数据库操作中也有些乐观锁和悲观锁的体现。

+ 开销对比

  悲观锁的原始开销要高于乐观锁，但是特点是**一劳永逸**，也不会对互斥锁的开销造成影响。

  相反，虽然乐观锁一开始开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么**消耗的资源也会越来越多**。

+ 两种锁各自的使用场景

  悲观锁：适合**并发写入多**的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗。典型情况有：

  1. 临界区有**IO操作**
  2. **临界区代码复杂或者循环量大**
  3. 临界区**竞争非常激烈**

  乐观锁：适合**并发写入少、大部分都是读取**的场景，不加锁能够让读取性能大幅度提高。



**可重入锁和非可重入锁**

+ **可重入**：已经获得了锁，再次申请这把锁的时候无需提前释放掉这把锁，而是可以直接继续使用这把锁。可重入锁也叫做递归锁，指的是同一个线程可以多次获取同一把锁。

  Java当中ReentrantLock是可重入锁，synchronized也是一种可重入锁。

+ 可重入性质的好处

  + **避免死锁**
  + 提升了**封装性**，减少了加锁解锁的步骤

+ 源码对比：可重入锁ReentrantLock以及**非可重入锁ThreadPoolExecutor的Worker类**。

+ ReentrantLock其他方法

  + isHeldByCurrentThread可以看出锁是否被当前线程持有。
  + getQueueLength可以返回当前正在等待这把锁的队列有多长。
  + getHoldCount可以获取到当前已经重入的次数。



**公平锁和非公平锁**

+ 什么是公平和非公平

  **公平**指的是按照线程请求顺序来分配锁；**非公平**指的是不完全按照请求的顺序，在**一定情况**下可以插队，非公平并不是提倡“插队”行为，而是指的**在“合适时机”插队**，而不是盲目插队。

+ 为什么要有非公平锁

  非公平的设计，目的是为了**提高效率，避免唤醒带来的空档期**。唤醒的过程需要时间和开销，在这期间为了增加吞吐量，就可以利用其这段空档期。

+ 公平与非公平的情况、公平与非公平的效果

  （ReentrantLock为例）如果在创建ReentrantLock对象时，参数填写true，那么就是一个公平锁。

+ 特例

  针对**tryLock()方法**，它不遵守设定的公平规则，例如，当有线程执行tryLock()的时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其它线程已经在等待队列里了，所以是自带“插队”性质。

+ 对比公平和非公平的优缺点

  公平锁：各线程是公平平等的，每个线程在等待一段时间后，总有执行的机会；但是更慢，吞吐量更小。

  非公平锁：更快，吞吐量更大；但是有可能产生**饥饿**，也就是某些线程在长时间内始终得不到执行。

+ 源码分析

  **公平锁在获得锁之前会判断下等待队列中是否有排队线程，而非公平锁会直接获取**。



**共享锁和排它锁**

+ 共享锁和排他锁的区别

  **排他锁**，又称独占锁、独享锁。**排他锁获取了锁以后既能读又能写**，但是其他线程再也没有机会获得排他锁了，只能由当前线程修改数据，保证了线程安全。

  **共享锁**，又称读锁，**获得共享锁后可以查看但是无法修改和删除数据**，其他线程此时也可以获取到共享锁，也可以查看但是无法删除和修改数据。

  共享锁和排他锁的典型就是**读写锁**ReentrantReadWriteLock，其中**读锁是共享锁，写锁是独享锁**。

+ 读写锁的作用

  在没有读写锁之前，我们假设使用ReentrantLock，那么虽然保证了线程安全，但是也**浪费了一定的资源**：多个读操作同时进行，并没有线程安全问题。那么在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果**没有写锁的情况下，读是无阻塞的**，提高了程序运行的效率。

+ 读写锁的规则

  + 多个线程只申请读锁，都可以申请到。
  + 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
  + 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。
  + 一句话总结：要么就是**一个或者多个线程同时有读锁；要么就是一个线程有写锁**。但是两者不会同时出现，要么多读，要么一写。

+ 读锁和写锁的交互方式

  ReentrantReadWriteLock不允许读锁插队，并且**只许降级**不能升级，也就是写锁可以降级为读锁，但是读锁不能升级成写锁。

  + 选择规则（公平非公平以及插队策略）

    公平锁：不允许插队

    非公平锁：写锁可以插队；读锁仅在等待队列头结点不是想获取写锁的线程的时候可以插队。（如果读锁任何情况都可以插队虽然可以提升效率，但是可能会造成写线程饥饿，一直无法获取锁。）

    源码：

  ```java
  public class ReentrantReadWriteLock{
      
      //省略。。。
      
      /**
       * Fair version of Sync
       */
      static final class FairSync extends Sync {
          private static final long serialVersionUID = -2274990926593161451L;
          final boolean writerShouldBlock() {
              return hasQueuedPredecessors();
          }
          final boolean readerShouldBlock() {
              return hasQueuedPredecessors();
          }
          //公平锁的情况，无论读锁还是写锁，都是需要先判断队列是否有排队线程，先排队的。
      }
      
      /**
       * Nonfair version of Sync
       */
      static final class NonfairSync extends Sync {
          private static final long serialVersionUID = -8159625535654395037L;
          //非公平锁，写者可以插队
          final boolean writerShouldBlock() {
              return false; // writers can always barge
          }
         
          final boolean readerShouldBlock() {
              /* As a heuristic to avoid indefinite writer starvation,
               * block if the thread that momentarily appears to be head
               * of queue, if one exists, is a waiting writer.  This is
               * only a probabilistic effect since a new reader will not
               * block if there is a waiting writer behind other enabled
               * readers that have not yet drained from the queue.
               */
              return apparentlyFirstQueuedIsExclusive();
              //非公平锁，会去看第一个是不是想获取写锁的线程，如果是就阻塞排队
          }
      }
      
      final boolean apparentlyFirstQueuedIsExclusive() {
          Node h, s;
          return (h = head) != null &&
              (s = h.next)  != null &&
              !s.isShared()         &&
              s.thread != null;
      }
  }
  ```

  + 锁的升降级

    为什么需要锁的升降级？是为了提升效率，假设一个任务先执行写再执行读，如果一直持有写锁就很浪费资源，如果可以锁降级就可以直接拿到读锁，而不需要释放掉而进行无法预期的读锁获取等待。

    实际情况是读写锁支持锁的降级，不支持升级！

    为什么不支持锁的升级呢？降级的好处在于可以提高效率，但是锁的升级容易造成死锁。因为一个读线程想要升级为写锁的时候需要其他读线程释放掉读锁才可以，可是如果多个读线程都想升级，这回陷入一种僵持状态。

+ 总结

  + ReentrantReadWriteLock主要有两个方法：ReadLock()和WriteLock()用来获取读锁和写锁。

  + 锁申请和释放策略

    多个线程只申请读锁，都可以申请到。如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程占用了写锁，则此时其他线程如果申请读锁或者写锁，则申请的线程会一直等待锁释放写锁。

    **要么多读，要么一写。**

  + 插队策略：为了防止饥饿，读锁不能插队。

  + 升降级策略：相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于**读多写少**的情况，合理是用可以进一步**提高并发效率**。



**自旋锁和阻塞锁**

+ 概念

  阻塞或者唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。

  如果物理机器有**多个处理器**，能够让两个或者以上的线程同时并行执行，我们就可以让后面的那个请求锁的线程能够不放弃CPU的执行时间，看看持有锁的线程会不会很快就释放锁。

  而为了让当前线程稍等一下去检测，需要让当前线程**自旋**，如果自旋完成后前面锁定同步资源的线程已经释放锁，那么当前线程就可以不必阻塞而直接获取同步资源，从而**避免切换线程的开销**。这就是自旋锁。

  阻塞锁和自旋锁相反，阻塞锁如果遇到没有拿到锁的情况，会直接把线程阻塞，直到被唤醒。

+ 缺点

  如果锁被占用时间过长，那么自旋的线程只会白白浪费处理器资源。在自旋过程中，一直消耗CPU，所以虽然自旋锁其实开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的。

+ 原理和源码分析

  JDK1.5版本及以上的并发包java.util.concurrent的atomic包下的类基本都是自旋锁的实现。比如AtomicInteger的实现：自旋锁的实现原理是**CAS**，AtomicInteger中调用unsafe进行自增操作的源码中do-while循环就是一个自旋操作，如果修改过程中遇到其他线程竞争而没修改成功，就**在while里死循环，知道修改成功**。

+ 适用场景

  所以自旋锁一般用于多核的服务器，在**并发度不是特别高**的情况中使用，比阻塞锁的效率高。另外，自旋锁适用于临界区比较短小的情况，否则临界区很大，线程一旦拿到了锁，很久才释放，就很不合适了，这会很浪费CPU资源。



**可中断锁**

顾名思义，可以响应中断的锁。在Java当中，synchronized就是不可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断。

如果某一线程A正在执行锁中的代码，另一线程B正在等待该锁，可能由于等待时间过长，线程B就不想等待了，想先处理其他事情，我们可以中断它，这就是可中断锁。



**锁优化**

+ Java虚拟机对锁的优化
  + 自旋锁和自适应
  
    + 互斥同步时，挂起和恢复线程都需要切换到内核态完成，这对性能带来了不少的压力。而有些情况共享数据的锁定状态只会持续很短的一段时间，为了这段较短的时间而去挂起和恢复线程并不值得。那么如果有多个线程同时并行执行，可以让后面请求锁的线程通过自旋（CPU忙循环执行空指令）的方式稍等一会儿，看看持有锁的线程是否会很快的释放锁，这样就不需要放弃 CPU 的执行时间了。
    + 在轻量级锁获取过程中，线程执行 CAS 操作失败时，需要通过自旋来获取重量级锁。如果锁被占用的时间比较短，那么自旋等待的效果就会比较好，而如果锁占用的时间很长，自旋的线程则会白白浪费 CPU 资源。解决这个问题的最简答的办法就是：指定自旋的次数，如果在限定次数内还没获取到锁（例如10次），就按传统的方式挂起线程进入阻塞状态。JDK1.6 之后引入了自适应性自旋的方式，如果在同一锁对象上，一线程自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么 JVM 会认为这次自旋也有可能再次成功获得锁，进而允许自旋等待相对更长的时间（例如100次）。另一方面，如果某个锁自旋很少成功获得，那么以后要获得这个锁时将省略自旋过程，以避免浪费 CPU。
  
  + 锁消除
  
  + 锁粗化
  
    [参考](https://www.cnblogs.com/butterfly100/p/8786856.html)
+ 实际代码编写中优化锁和提高并发性能
  + 缩小同步代码块
  + 尽量不要锁住方法
  + 减少请求锁的次数
  + 避免人为制造“热点”，也就是需要互斥访问的内容。
  + 锁中尽量不要包含锁，否则容易造成死锁。
  + 选择合适的锁类型以及合适的工具类。

