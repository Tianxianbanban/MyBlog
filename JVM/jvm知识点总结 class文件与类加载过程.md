#### jvm知识点总结 class文件与类加载过程

1. 什么是jvm的语言无关性和java的平台无关性？

   + JVM的语言无关性

     java虚拟机只与Class文件这种特定的二进制格式的文件相关联，但是并不关心Class文件来源与何种语言，java之外还有很多语言都可以编译成class二进制字节码。

   + java的平台无关性

     虚拟机提供商们提供了发布了不同平台的虚拟机，这些虚拟机可以载入和执行同一种平台无关的字节码，实现一次编写到处运行。

2. class文件的特点是什么？

   + Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中， 中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据， 没有空隙存在。 当遇到需要占用8位字节以上空间的数据项时， 则会按照高位在前的方式分割成若干个8位字节进行存储。 

3. class文件由哪几个部分组成，每个部分有什么用？

   + Class文件采用类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型，无符号数和表，其中无符号数可以表示数字、索引引用、数量值或者按照UTF-8编码构成字符串值。表是由多个无符号数或者其他表作为数据项构成的复合数据类型。

     + 进行身份识别的**魔数**
     + **次版本号**与**主版本号**
     + **常量池容量**与**常量池**：常量池中主要存放两大类常量即字面量与符号引用。
     + 访问标志
     + 类索引、 父类索引与接口索引集合
     + 字段表集合
     + 方法表集合
     + 属性表集合

     ![1565246388869](C:\Users\CY\AppData\Roaming\Typora\typora-user-images\1565246388869.png)

4. 字节码指令有哪些特点？

   + Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作码， Opcode） 以及跟随其后的零至多个代表此操作所需参数（称为操作数， Operands） 而构成。

5. 你知道有哪些字节码指令？

   + 加载与存储指令
   + 运算指令
   + 类型转换指令
   + 对象创建与访问指令
   + 操作数栈管理指令
   + 控制转移指令
   + 方法调用和返回指令
   + 异常处理指令
   + 同步指令

6. 类加载有哪些过程？

   **加载、验证、准备、解析、初始化、使用、卸载**；

   其中加载、验证、准备、初始化、卸载五个阶段时顺序开始的，解析阶段则不一定，有可能会在初始化阶段之后再开始。

7. 什么情况下会进行类的加载？

   虚拟机规范并没有对类的加载的具体情况进行强制约束，虚拟机规范严格规定在以下五种情况会对类进行**初始化**，那么**加载**一定会在此之前进行:

   + 使用new关键字实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）的时候， 以及调用一个类的静态方法的时候。
   + 对类进行反射调用的时候。
   +  当初始化一个类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化。
   +  当虚拟机启动时， 用户需要指定一个要执行的主类（包含main()方法的那个类） ， 虚拟机会先初始化这个主类。
   + 当使用JDK 1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、 REF_invokeStatic的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化。

8. 类加载的每个过程都分别做了什么？

   + 加载：

     + 通过一个类的全限定名来获取定义此类的**二进制字节流**。
     + 将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构**。
     + 在内存中生成一个**代表这个类的java.lang.Class对象**， 作为方法区这个类的各种数据的访问入口。

   + 验证：

     + 文件格式验证：验证字节流是否**符合Class文件格式的规范**， 并且**能被当前版本的虚拟机处理**。只有通过了这个阶段的验证后， 字节流才会进入内存的方法区中进行存储， 所以后面的3个验证阶段全部是基于方法区的存储结构进行的， 不会再直接操作字节流。
     + 元数据验证：对字节码描述的信息进行**语义分析**， 以保证其描述的信息符合Java语言规范的要求。比如这个类是否有父类，其父类是否继承了不允许继承的类等等。
     + 字节码验证：通过数据流和控制流分析， 确定程序语义是合法的、 符合逻辑的。 在第二阶段对元数据信息中的数据类型做完校验后， 这个阶段将**对类的方法体进行校验分析**， 保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
     + 符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候， 这个转化动作将在连接的第三阶段即解析阶段中发生，通常会校验符号引用中通过字符串描述的全限定名是否能找到对应的类；在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；符号引用中的类、 字段、 方法的访问性是否可被当前类访问等等。

   + 准备：

     + 准备阶段是正式**为类变量分配内存并设置类变量初始值**的阶段， 这些变量所使用的内存都将在**方法区**中进行分配。 

   + 解析：

     + 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、 字段、 类方法、 接口方法、 方法类型、 方法句柄和调用点限定符7类符号引用进行， 分别对应于常量池的7种常量类型。

       + 类或接口的解析：如果不是数组类型，就把该类的全限定名传递给引用该类的当前类的类加载器去加载；如果是数组类型，会先加载数组元素类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象。以上步骤没有出现异常，在解析完成之前还要进行符号引用验证，确认对它的访问权限。

       + 字段解析：首先对字段表内的class_index项中的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或者接口的符号引用。如果字段所属的类或者接口本身包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。否则，如果这个这个类实现了接口，将会按照递归从下往上搜索各个接口和父接口，如果接口中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。否则，如果这个类不是Object类的话，会按照继承关系从下往上递归搜索父类，如果在父类中包含了简单名称和字段描述符都与目标匹配的字段，就返回这个字段的直接引用，查找结束。否者查找失败抛出异常。

       + 类方法解析：解析出所属类或者接口的符号引用，从所属类中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。否则在其父类中递归查找是否有简单名称和描述符斗鱼目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。否则，在所属类实现的接口列表以及他们的父接口中递归查找是否有简单名称和描述符都与目标匹配的方法，如果存在匹配的方法，说明所属类是一个抽象类，这是查找结束并且抛出java.lang.AbstractMethodError异常。否则，宣告查找失败并且抛出java.lang.NoSuchMethodError异常。

         查找成功返回直接引用，会对这个方法进行权限验证，如果不具备对次方法的访问权限，将抛出java.lang.IllegalAccessError异常。

       + 接口方法解析：首先解析方法所属的类或者接口的符号引用，如果所属的类或者接口是个类而不是接口则抛出java.lang.IncompatibleClassChangeError异常。否则就在所属接口中查找是否有简单名称和描述符都与目标相匹配的的方法，如果有就返回这个方法的直接引用，查找结束。否则就继续递归查找父接口，知道Object类位置，如果有简单名称和描述符都与目标想匹配的方法，就返回这个方法的直接引用，查找结束。否则就宣告查找失败，抛出java.lang.NoSuchMethodError异常。

   + 初始化：初始化阶段才真正开始执行类中定义的java代码，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，也就是执行类构造器＜clinit＞()方法的过程。

9. 如何确定两个类对象是相等的？

   对于任意一个类，都需要有加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类也必定不相等。

10. 双亲委派模型是什么？

    从java虚拟机的角度看有虚拟机自身的启动类加载器以及独立于虚拟机外部的其他类加载器。

    从java开发人员的角度来看绝大部分的Java程序会用到这三种系统提供的**类加载器**：

    + 启动类加载器：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 `java.lang.ClassLoader`。
    + 扩展类加载器：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
    + 应用程序类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 `ClassLoader.getSystemClassLoader()`来获取。

    我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们可以加入自己定义的类加载器。这些类加载器之间的关系：

    ![1565536880463](C:\Users\CY\AppData\Roaming\Typora\typora-user-images\1565536880463.png)

    这种层次关系就成为**类加载器的双亲委派模型**：双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这种类加载器的父子关系一般不会以继承的关系来实现，而都是使用组合关系来复用父加载器的代码。

11. 双亲委派模型有什么用？

    我们已经知道类的在虚拟机当中的唯一性由类本身和它对应的类加载器共同确定。

    那么双亲委派模型也就是让类和对应的类加载器具备了一种带有优先级的层次关系，最典型的例如Object类， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都是同一个类。双亲委派模型也就因此避免了某些恶意类的加载，也保证了每个类不会重复加载。

12. 破坏双亲委派模型有哪些例子？

    双亲委派模型主要出现过三次”大规模“被破坏的情况。

    第一次是JDK1.2也就是出现双亲委派模型之前，重写加载器的loadClass()方法，JDK1.2之后添加了findclass()方法来保证新写出来的类加载器符合双亲委派规则。

    第二次是由于双亲委派模型自身的缺陷，对于SPI思想实现的束缚，引入了线程上下文类加载器。

    第三次是为了实现热替换、模块热部署等，实现增加或减少一个功能，只需要将这个模块和其对应的类加载器一同替换的代码热替换。

13. 方法调用是什么？

14. java的多态与什么机制有关？

15. java是一门静态多分派和动态单分派语言，那么什么是静态多分派和动态单分派呢？

16. 虚拟机是如何实现动态单分派的？

17. 虚拟机为了支持动态语言做了什么？



