## 关于内存泄露

**内存泄露\内存溢出\内存抖动**

**内存溢出**是指应用系统中**存在无法回收的内存或使用的内存过多**，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序运行不了，系统会提示内存溢出，有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件，而由系统配置、数据流、用户代码等原因而导致的内存溢出错误，即使用户重新执行任务依然无法避免。Android 会为每个应用程序分配 一个可用的内存最大值，这时候会报 OOM 异常。

**内存泄露**指的是一些已经不再用到的引用或者对象由于一些原因没有释放或者无法释放而仍然长期保存在内存中，造成内存资源的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

 **内存抖动**是由于短时间内创建大量的对象然后很快释放，内存频繁地分配和回收会伴随频繁的GC，GC会大量占用CPU资源，会导致APP整体卡顿，严重时和内存泄漏一样会导致OOM。



**造成内存泄漏的原因**

+ 类的静态变量持有大数据对象：静态变量长期持有大数据对象的引用，阻止垃圾回收，因为静态变量的生命周期是整个应用程序。 
+ 资源对象未关闭：资源对象比如 Cursor 游标，File 对象，Bitmap 资源，往往用到了缓冲，我们在不需要的时候一定要记得及时关闭他们，以便他们的缓冲及时被回收，如果我们仅仅只是将他们的引用设置成 null 而不关闭他们，往往会造成内存泄漏，因此在使用这些对象的时候一 定注意最后手动调用他们的 close 方法关闭掉，一般这个关闭操作是出现在 try catch finally 语句的 finally 部分的，在关闭之后将这些对象赋值为 null 即可。
+ 单例模式造成的内存泄漏：在 Android 中使用单例模式的时候，由于单例模式的静态特性往往会导致该单例的生命周期和应用的生命周期一样长，而我们在创建单例对象的时候经常要传入 Context 上下文，我们都知道 Android 中的 Context 有三种，如果传入的是 Application 的 Context，自 然没什么问题，因为这个 Context 本身的作用域就是整个应用；但是如果传入的是 Activity 的 Context 就有可能造成内存泄漏了，因为在 Activity 退出的时候，由于他的 Context 被单例对象所持有着，那么造成了他不会被回收掉，出现内存泄漏； 解决方法是：在 Android 中创建单例对象的时候，如果要涉及到传入 Context 上下文， 最好传入Application的Context。但是 Application的Context并不是万能的，对于Dialog 而言，他是只能出现在 Activity 中的，Application 可以通过 getApplicationContext 获 得，最好不要通过 getApplication，因为该方法仅适合于 Activity 和 Service 不适于 BroadcastReceiver 等其他组件中。
+ 尽量避免使用 static 成员变量：因为将一个变量声明为 static 的话，意味着其生命周期将和应用程序是一样的，这会带来一系列问题，比如你的 App 进程假如设计成是常驻内存的，即使你切换到后台，由 static 所持有的对象资源将不会释放，而系统的管理机制会将占用内存较大的后台进程优先回收掉，这回导致你的应用程序经常性的被回收。 
+ Handler 造成的内存泄漏：因为 Handler 的生命周期和 Activity 是不一致的，所以经常会带来内存泄漏的问题， 比如有这样一种情形，在 Activity 中定义了一个继承自 Handler 的非静态内部类，并通过他发送了一条消息，该消息会在 10 分钟之后返回当前时间，接着我们将 Activity 退出了，但是此时 Activity 并不会被 GC 回收掉的，原因在于我们的消息任务还在 MessageQueue 中排队，那么 Handler 是无法释放的，而 Handler 本身又持有外部类 Activity 的引用，那么也就导致了 Activity 没有释放了，造成内存泄漏，解决措施也是将非静态内部类设置成 static 类型的，同时为了高效率的回收，我们可以将所引用的外部类的实例在内部类中设置成 WeakReference 类型，也就是弱引用类型，此外为了防止 Looper对象的内存泄漏，我们可以在Activity销毁的时候调用removeCallbackAndMessages 方法，移出 MessageQueue 里面的所有消息。
+  注册监听器之后没有解注册： Android 中存在许多需要 register 与 unregister 的监听器，我们需要在适当的时候 及时 unregister 那些监听器，自己手动 add 的 listener 一定要记得及时 remove 这个 listener。
+ 一些不良的编程习惯： 比如在使用 Bitmap 的时候没有调用 recycle 方法，对于 Bitmap 对象在不使用的时候， 我们应该首先使用 recycle 方法释放掉内存然后再设置为 null，如果直接设置 null 的 话只是将 java 层面的对象吧释放掉了，但是 Bitmap 的操作是要用到 C 层面的东西的， recycle 的作用就是释放掉 C 层面的；在比如构造 ListView 的 Adapter 时候，没有使用缓存的 convertView，每次都是创建新的 convertView等等。



**避免 OOM 异常的措施**

+ 使用更加轻量级的数据结构： 可以考虑使用 ArrayMap/SparseArray 来代替 HashMap，原因在于通常的 HashMap 更 加占用内存，因为他需要一段空间来存储我们 的 Mapping 操作，而很多情况下这些空间是 不会得到充分利用的，ArrayMap 采用两个数组来实现，一个数组用于存储 key 值 hash 之后 的顺序列表，另一个数组存储按 key 的顺序记录的 key-value 值，当你想要获得某个 value 值的时候，ArrayMap 会计算输入 key 转换之后的 hash 值，然后对通过二分查找的方式寻找 到这个 hash 值在 hash 值数组中的位置 index，有了这个 index 我们便可以在另外一个数组中直接访问到需要的键值对了，如果第二个数组键值对中的 key 和当前输入的 key 不一致， 则发生了碰撞冲突，为了解决这个问题，我们会以该 key 为中心，上下去查找比对，直到找到匹配的值为止；而对于 SparseArray 来说，他的高效性体现在他避免了对 key 和 value 的自动装箱操作，并且避免了装箱之后的解箱操作。
+  尽量在不在Android 中使用 Enum 枚举类型：原因在于枚举类型在运行的时候会带来额外的内存占用。
+  减少 Bitmap 对象的内存占用： Bitmap 是极容易消耗内存的家伙，通常我们可以这么做：使用它的 inSampleSize 缩放比例属性，在图片加载到内存之前，我们首先获取到图片大小，计算出适当的缩放比例出来，避免不必要的大图加载占用内存操作；其次我们可以使用适当的解码格式， ARGB_8888/ARGB_4444 /RGB_565 解码方式不同，每个像素点占用的字节数就不同。
+ 使用更小的图片： 尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的 InflationException，假设有一张很大的图片被 XML 文件直接引用，很有可能在初始化的时候就会导致内存不足而引发 InflationException 。
+ 尽量对内存中的对象进行复用：具体实现措施有以下几种： 重用系统自带的资源，比如字符串/颜色/图片/动画等； 注意在 ListView/GridView 等出现大量重复子组件的视图中对 ConvertView 的 复用； 使用 LRU 对 Bitmap 图片进行缓存； 使用 inBitmap 的高级特性提高 Android 系统在 Bitmap 分配与释放执行效率上 的提升，使用 inBitmap 可以告诉 Bitmap 解码器尝试 使用已经存在的内存区域，新解码的 Bitmap 会尝试使用之前那张 Bitmap 在 heap 中所使用的内存区域，而不是取内存重新申请 一块区域来存放 Bitmap，这样的话，即使有上千张图片，也只会占用屏幕所能显示图片数 量的内存大小，但是使用 inBitmap 有两个限制条件，一是新申请的 Bitmap 大小必须小于 或者等于已经赋值的 Bitmap 大小；二是新申请的 Bitmap 解码方式必须与旧 Bitmap 的解码 方式相同，大家都是 ARGB_8888 就都是，我们可以创建一个包含多种典型可重用的 Bitmap 对象池，这样的话，后续的 Bitmap 就都能找到合适的"模板"去复用了。
+ 避免在 onDraw 方法中执行对象的创建： 因为 onDraw 方法的调用频率比较高，一定要注意避免在这个方法里面进行创 建对象的操作，因为他会迅速增加内存的使用，容易引起频繁的 GC 操作，甚至可能出现内存的抖动现象。
+ StringBuilder 的使用： 在大量使用到字符串拼接操作的地方可以用 StringBuilder 来代替“+”，但 是有一点需要注意的就是，StringBuilder 是非线程安全的。
+ 注意单例对象中不合理的持有其他对象这种情况，因为单例的生命周期是和应 用保持一致的，使用不合理很容易会导致持有对象的泄漏； 



**内存泄露监测方法**

使用 DDMS 中的中的内存监测工具 Heap，使用步骤如下： (1)：启动 eclipse，切换到 DDMS 视图，并且确保 Devices 视图和 Heap 视图都已经打 开； (2)：连接设备，确保设备处于"USB 调试状态"； (3)：选中想要监测的进程 (4)：点击 Devices 视图最上面一排图标中的"Update Heap"图标； (5)：点击 Heap 视图中的"Cause GC"按钮； (6)：此时 Heap 视图中就会显示当前选中进程内存使用的详细情况了； 说明： (1)：点击"Cause GC"按钮相当于向虚拟机请求一次 GC 操作； (2)：如何才能知道我们程序是否存在内存泄漏的可能性呢？方法是 Heap 视图中有一 个 Type 叫做 data object，即数据对象，也就是我们程序中存在的大量的类类型的对象， 在 data object 一行中有一列"Total Size"，其值就是当前进程中所有 Java 数据对象的内 存总量，一般情况下，我们可以通过这个值来查看是否发生了内存泄漏；不断的操作当前应 用，同时注 意观察 Total Size 的值，正常情况下，这个值是维持在一个有限的范围的，如 果代码存在没有被释放引用的情况，则 data object 的 Total Size 值在每次 GC 之后不会有 明显的回落，随着操作次数的增多，Total Size 的值会越来越大； 



**[其他](https://omq96c5ejc.feishu.cn/docx/doxcn0L9eXhnM4EswXwFoZA63Qf)**

