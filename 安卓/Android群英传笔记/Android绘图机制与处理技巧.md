## Android绘图机制与处理技巧



**屏幕的尺寸信息**

+ 屏幕参数

  + 屏幕大小

    手机对角线长度，寸。5.5寸

  + 分辨率

    手机屏幕的像素点个数，也就是长宽像素点的乘积。720*1280

  + DPI

    每英寸像素（Dots Per Inch），对角线的像素点数除以屏幕大小得到。

+ 系统屏幕密度

  系统定义了几个标准DPI值

  | 密度   | ldpi    | mdpi    | hdpi    | xdpi     | xxdpi     |
  | ------ | ------- | ------- | ------- | -------- | --------- |
  | 密度值 | 120     | 160     | 240     | 320      | 480       |
  | 分辨率 | 240*320 | 320*480 | 480*800 | 720*1280 | 1080*1920 |

+ 独立像素密度dp

  各种屏幕密度的不同，导致同样像素大小的长度，在不同密度的屏幕上显示长度不同。相同长度的屏幕，高密度的屏幕包含更多的像素点。

  因此Android系统使用mdpi即密度值为160的屏幕作为标准，在这个屏幕上1px= 1dp。其他屏幕则可以通过比例进行换算。ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12。

+ 单位转换

  可以编写自己转换代码工具类。



**2D绘图基础**

+ Paint
  + setAntiAlias() 锯齿效果
  + SetColor() 颜色
  + SetARGB() A、R、G、B值
  + SetAlpha Alpha值
  + SetTextSize() 字体尺寸
  + SetStyle() 画笔风格（空心或者实心）
  + SetStrokeWidth() 空心边框的宽度

+ Canvas

  有的可以通过传入一个数组，绘制多个对象。

  + drawPoint （点）
  + drawLine （线）
  + drawRect（矩形）
  + drawVertices （多边形）
  + drawArc （弧）
  + drawCircle （圆）



**Android XML绘图**

XML有几个强大的技能

+ Bitmap
+ Shape
+ Layer
+ Selector



**Android绘图技巧**

+ Canvas

  + Canvas.save() 保存绘制图像
  + Canvas.restore() save之后绘制的图像与save之前绘制的图像进行合并
  + Canvas.translate() 平移画布
  + Canvas.rotate() 画布翻转

+ Layer图层

  使用saveLayer()方法来创建一个图层，图层同样是基于栈的结构进行管理的。Android通过调用saveLayer()方法、 savaLayerAlpha()方法将一个图层入栈，使用restore()方法、restoreToCount()方法将一个图层出栈。入栈的时候，后面所有的操作都发生在这个图层上，而出栈的时候，则会把图像绘制到上层Canvas上。



**Android图像处理之色彩特效处理**

Android对于图片的处理，最常使用到的数据结构是位图——Bitmap，它包含了一张图片所有的数据。整个图片都是由点阵和颜色值组成的，所谓点阵就是一个包含像素的矩阵，每一个元素对应着图片的一个像素。而颜色值——ARGB，分别对应透明度、红、绿、蓝这四个通道分量，它们共同决定了每个像素点显示的颜色

+ 色彩矩阵分析

  对于每个像素点，都有一个颜色分量矩阵用来保存颜色的RGBA值。4*5

  + 第一行的abcde值用来决定新的颜色值中的R——红色
  + 第二行的fghij值用来决定新的颜色值中的G——绿色
  + 第三行的klmno值用来决定新的颜色值中的B——蓝色
  + 第四行的pqrst值用来决定新的颜色值中的A——透明度
  + 矩阵A中的第五列——ejot值分别用来决定每个分量中的offset，即偏移量

  那么当我们要变换颜色值的时候，通常有两种方法。一个是直接改变颜色的offset，即偏移量的值来修改颜色分量，另一个方法是直接改变对应RGBA值的系数来调整颜色分量的值。

  1. 改变偏移量

  2. 改变颜色系数

  3. 改变色光属性

     Android系统中封装了一个类ColorMatrix，就是对应的颜色矩阵，通过这个类可以很方便地通过改变矩阵值来处理颜色效果。

     + 色调
     + 饱和度
     + 亮度

+ Android颜色矩阵——ColorMatrix

+ 常用图像颜色矩阵处理效果

  + 灰度效果
  + 图像翻转
  + 怀旧效果
  + 去色效果
  + 高饱和度

+ 像素点分析

  作为更加精确的图像处理方式，可以通过改变每个像素点的具体ARGB值，来达到处理一张图像效果的目的。这里要注意的是，传递进来的原始图片是不能修改的（mutable），一般根据原始图片生成一张新的图片来修改。

  在Android中，系统提供了Bitmap.getPixels()方法来帮我们提取整个Bitmap中的像素点，并保存到一个数组中。接下来，就可以获取到每个像素具体的ARGB值了。当获取到具体的颜色值之后，就可以通过相应的算法来修改它的ARGB值，从而来重构一张新的图像。当然，这些算法都是前辈们研究、总结出来的图像处理算法，由于我们不是专业的图像处理人员，所以就直接拿来用了。然后将新的RGBA值合成像素点。将处理之后的像素点数组重新set给我们的Bitmap，从而达到图像处理的目的。

+ 常用图像像素点处理效果

  + 底片效果
  + 老照片效果
  + 浮雕效果



**Android图像处理之图形特效处理**

+ Android变形矩阵——Matrix

  对于图像的图形变换，Android系统也是通过矩阵来进行处理的，每个像素点都表达了其坐标的X、Y信息。Android的**图形变换矩阵**是一个3×3的矩阵。使用变换矩阵去处理每一个像素点的时候，与颜色矩阵的矩阵乘法是一样的，处理方式类似。

  图像的变形处理通常包含四类基本变换：

  + Translate——平移变换

    即将每个像素点都进行平移变换，对应一个平移变换矩阵。

  + Rotate——旋转变换

    即指一个点围绕一个旋转中心旋转到一个新的点，对应一个选择变换矩阵。

  + Scale——缩放变换

    一个像素点是不存在缩放的概念的，但是由于图像是由很多个像素点组成的，如果将每个点的坐标都进行相同比例的缩放，最终就会形成让整个图像缩放的效果，对应一个缩放变换矩阵。

  + Skew——错切变换

    错切变换的效果就是让所有点的X坐标(或者y坐标)保持不变，而对应的y坐标（或者X坐标)则按比例发生平移，且平移的大小和该点到X轴（或y轴）的垂直距离成正比。错切变换通常包含两种——水平错切与垂直错切，对应一个错切变换矩阵。

  与色彩矩阵一样，Android系统同样提供了一些API来简化矩阵的运算：

  + matrix.setRotate()——旋转变换
  + matrix.setTranslate()——平移变换
  + matrix.setScale()——缩放变换
  + matrix.setSkew()——错切变换
  + pre()和post()——提供矩阵的前乘和后乘运算

+ 像素块分析

  drawBitmapMesh()与操纵像素点来改变色彩的原理类似，只不过是把图像分成了一个个的小块，然后通过改变每一个图像块来修改整个图像，在图像上横纵各画N-1条线，将图像分成N块，而这横纵各N条线就交织成了N×N个点，当改变某些交叉点的坐标时，就会让整个像素块随之发生扭曲



**Android图像处理值画笔特效处理**

+ PoterDuffXfermode
+ Shader
+ PathEffect



**View的孪生兄弟——SurfaceView**

+ SurfaceView与View的区别

  Android系统提供了View进行绘图处理，View可以满足大部分的绘图需求，但在某些时候，却也有些心有余而力不足，特别是在进行一些开发的时候。我们知道，View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的间隔时间为16ms。如果在16ms内View完成了你所需要执行的所有操作，那么用户在视觉上，就不会产生卡顿的感觉；而如果执行的操作逻辑太多，特别是需要频繁刷新的界面上，例如游戏界面，那么就会不断阻塞主线程，从而导致画面卡顿。

  为了避免这一问题的产生，Android系统提供了SurfaceView组件来解决这个问题。SurfaceView可以说是View的孪生兄弟，但它与View还是有所不同的，它们的区别主要体现在以下几点。

  +  View主要适用于主动更新的情况下，而SurfaceView主要适用于**被动更新**，例如频繁地刷新。

  + View在主线程中对画面进行刷新，而SurfaceView通常会通过一个**子线程来进行页面的刷新**。 

  + View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现机制中就已经实现了**双缓冲机制**。
  
  总结成一句话就是，如果你的自定义View需要频繁刷新，或者刷新时数据处理量比较大，那么你就可以考虑使用SurfaceView来取代View了。
  
+ SurfaceView的使用

  对应的是一个模板代码，需要理解，和灵活修改。

+ SurfaceView实例

  正弦曲线

  绘图板

  等等