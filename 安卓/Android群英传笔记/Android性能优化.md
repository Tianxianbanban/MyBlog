## Android性能优化



**布局优化**

+ Android UI 渲染机制

  人眼所感觉的流畅画面，需要画面的帧数达到40帧每秒到60帧每秒，相信玩过PC游戏的朋友应该对帧数的概念非常清楚，**最佳fps大概在60fps左右**，这也是评价一个显卡性能高低的标准之一。在Android中，系统通过VSYNC信号触发对UI的渲染、重绘，其间隔时间是16ms。这个16ms其实就是1000ms中显示60帧画面的单位时间，即1000/60。如果系统每次渲染的时间都保持在16ms之内，那么我们看见的UI界面将是非常流畅的，但这也就需要将所有程序的逻辑都保证在16ms内。如果不能在16ms内完成绘制，那么就会造成丢帧现象，即当前该重绘的帧被未完成的逻辑阻塞，例如一次绘制任务耗时20ms，那么在16ms系统发出VSYNC信号时就无法绘制，该帧就被丢弃，等待下次信号才开始绘制，导致16*2ms内都显示同一帧画面，这就是画面卡顿的原因。

  Android系统提供了**检测UI渲染时间的工具**，通过开发者选项打开。每一条柱状线都包含三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间。中间的绿色横线代表VSYNC时间16ms，需要尽量将所有条形图都控制在这条绿线之下。

+ 避免Overdraw

  过度绘制会浪费很多的CPU、GPU资源。Android系统在开发者选项中提供了这样一个检测工具，通过这个工具可以查看当前区域中的绘制次数，从而尽量优化绘图层次，尽量增大蓝色的区域、减少红色区域。

+ 优化布局层级

+ 避免嵌套过多无用布局

  + 使用<include>标签重用Layout
  + 使用<ViewStub>实现View的延迟加载

+ Layout Inspector

  通过这个检测工具，能够很快在视图树中找到冗余的布局。



**内存优化**

+ 什么是内存

+ 获取Android系统内存信息

  + Process Stats
  + Meminfo

+ 内存回收

  Java对于C、C++这类语言最大的优势就是不用手动管理系统资源，Java创建了垃圾收集器线程（GarbageCollection Thread）来自动进行资源的管理。这样做的好处是大大降低了程序开发人员对内存管理的繁琐工作。但这也带来了很多问题，例如Java的GC是系统自动进行的，但何时进行却是开发者无法控制的，即使调用System.gc()方法，也只是建议系统进行GC，但系统是否采纳你的建议，那就不一定了。JVM虚拟机虽然能够自动控制GC，但是再强大的算法，也难免会存在部分对象忘记回收的现象发生，这就是造成内存泄漏的原因。

+ 内存优化实例

  + Bitmap优化

  + 代码优化

    任何Java类，都将占用大约500字节的内存空间。创建一个类的实例会消耗大约15字节的内存。从代码的实现方式上，也可以对内存进行优化，这里同样总结了一些小的技巧。

    + 对常量使用static修饰符。
    + 使用静态方法，静态方法会比普通方法提高15%左右的访问速度。
    + 减少不必要的成员变量，这点在Android Lint工具上已经集成检测了，如果一个变量可以定义为局部变量，则会建议你不要定义为成员变量。
    + 减少不必要的对象，使用基础类型会比使用对象更加节省资源，同时更应该避免频繁创建短作用域的变量。
    + 尽量不要使用枚举、少用迭代器。
    + 对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收与注册、解注册。
    + 避免使用IOC框架，IOC通常使用注解、反射来进行实现，虽然现在Java对反射的效率已经进行了很好的优化，但大量使用反射依然会带来性能的下降。
    + 使用RenderScript、OpenGL来进行非常复杂的绘图操作。
    + 使用SurfaceView来替代View进行大量、频繁的绘图操作。
    + 尽量使用视图缓存，而不是每次都执行inflate()方法解析视图。



**Lint工具**



**Android Studio 的 Memory Monitor工具**

较浅的蓝色代表free的内存，而深色的部分代表使用的内存从内存变换的走势图变换



**使用TraceView工具优化APP性能**



**使用MAT工具分析APP内存状态**



**使用Dumpsys命令分析系统状态**

