## 操作系统——进程管理



### **进程与线程**

+ 进程的概念和特征

  + 进程的概念

    是**具有独立功能**的程序在一个数据集合上运行的过程，它是系统进行**资源分配和调度的一个独立单位**。

  + 进程的特征

+ 进程的状态与转换

  + 新建

    进程正在被创建，尚未转到就绪状态。

  + 就绪

    进程处于准备运行的状态， 即**获得了除处理机之外的一切所需资源**，一旦得到处理机即可运行。

  + 运行

    进程正在处理机上运行。

  + 阻塞

    进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或者等待输入/输出完成。即使处理机空闲，该进程也不能运行。

  + 终止

    进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。

    ![image-20200428114151731](upload\image-20200428114151731.png)

    就绪状态无法直接进入阻塞状态，阻塞状态等待事件完成后会进入就绪状态。

+ 进程控制

  + 进程的创建
  + 进程的终止
  + 进程的阻塞与唤醒
  + 进程切换

+ 进程的组织

  + 进程控制块
  + 程序段
  + 数据段

  

#### 进程的通信

  + 管道通信

    管道是一种**半双工**的通信方式，可以看做是一种**只存在于内存中的特殊的文件**。管道只能用于具有亲缘关系的进程之间的通信，如父子进程/兄弟进程等。

    管道通信是消息传递的一种特殊方式，管道就是**连接一个读进程和一个写进程来实现它们之间通信的一个共享文件**，pipe文件，向管道提供输入的发送进程（写进程）以字符流的形式将大量数据写入管道，接收管道输出的接收进程（读进程）从管道中接收数据，管道机制当中需要提供互斥、同步和确定对方存在的协调能力，然后管道和一般文件也不同，它可以克服使用文件进行通信的两个问题，可以限制管道的大小，实际上是个固定大小的缓冲区，空间不够写进程会被阻塞，同样读进程如果比写进程快，缓冲区为空的时候读进程会被阻塞，另外管道通信是半双工通信，某一时刻只能单向传输。

  + FIFO

    也称为**命名管道**，去除了管道只能在父子进程中使用的限制。FIFO也是以一种特殊的文件存放在内存中，但是FIFO文件有一个路径名，所以可以在无关的进程之间交换数据。

  + 共享存储

    共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区，信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

  + 消息传递

    消息传递，进程间的数据交换就是以格式化的消息为单位的，要利用操作系统提供的消息传递方法，发送消息接收消息的**原语**进行数据交换，实现进程间通信。

    消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

  + 信号量

    信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。它是一个计数器，用于为多个进程提供对共享数据对象的访问。

  + Socket

    通过网络或者是本地socket。与其它通信机制不同的是，它可用于不同机器间的进程通信。



  

#### 线程概念与多线程模型

+ 线程的基本概念

  线程是操作系统能够**进行运算调度的最小单位**。它**被包含在进程之中**，是进程中的实际运作单位。

+ 线程与进程的比较

  + 调度

    在传统的操作系统当中，拥有资源和独立调度的基本单位都是进程。

    而在引入线程的操作系统当中，线程是**独立调度的基本单位**，进程则是**拥有资源的基本单位**。在同一个进程中切换线程不会引起进程切换，而在不同进程中进行线程的切换是会引起进程切换的。

  + 拥有资源

    无论是传统的操作系统还是引入线程的操作系统，**进程都是拥有资源的基本单位**，而**线程是不拥有系统资源**的，只具有一点必不可少的资源。但是线程可以访问自己隶属的进程的系统资源，毕竟假如说线程也作为一个拥有资源的单位，那么线程的切换开销也会很大了，所以线程的提出也会因此而变得没有意义。

  + 并发性

    引入线程的操作系统当中，不仅是进程之间可以并发执行，而且多个线程之间也可以并发执行，使操作系统具有更好的并发性，提高系统吞吐量。

  + 系统开销

    由于创建和撤销进程时，系统都要为它分配或者回收资源，比如内存空间、I/O设备等等，所以操作系统付出的开销远远大于创建或者撤销线程时的开销。类似地，在进行进程切换时，涉及到当前执行进程**CPU环境的保存以及新调度到的进程CPU环境的设置**，而线程切换时**只需要保存和设置少量寄存器内容**，开销很少。另外，同一个进程内的多个线程共享进程的地址空间，所以这些线程之间的同步与通信都会更加容易实现，甚至都不需要操作系统的干预。

  + 地址空间和其他资源

    进程之间的地址空间是相互独立的，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。

  + 通信方面

    进程间通信（**IPC**）需要进程同步和互斥手段的辅助，以保证数据的一致性；而线程间通信可以直接读/写进程数据段（如全局变量）来进行通信。

+ 线程的属性

+ 线程的实现方式

  + 用户级线程

    从用户视角看的线程。有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。

  + 内核级线程

    从操作系统的视角看到的线程（内核级线程才是处理机分配的单位）。线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口

  + 组合方式

+ 多线程模型

  + 多对一模型

    将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见。

    优点：线程管理是在用户空间进行的，因而效率比较高。
    缺点： 当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞：多个线程不能并行
    地运行在多处理机上。

  + 进程管理开销小效率高；但一个用户级线程在使用内核服务时阻塞会导致整个进程都阻塞（并发度低）。

  + 一对一模型

    将每个用户级线程映射到一个内核级线程。

    优点：当一个线程被阻塞后，允许另一个线程继续执行，所以**并发能力强**。
    缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的**开销比较大**，会影响到应用程序的性能。

  + 多对多模型

    将n 个用户级线程映射到m 个内核级线程上

    在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。又拥有多对一模型和一对一模型各自的优点，可谓**集以上两者所长**。



### **处理机调度**

+ 调度的概念

  + 调度的基本概念
  + 调度的层次
  + 三级调度的关系

+ 调度的时机、切换与过程

+ 进程调度方式

+ 调度的基本准则

+ 典型的调度算法

  + 先来先服务调度算法（FCFS）

    作业调度中，每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。

    进程调度中，每次从**就绪队列**中选择**最先进入该队列的进程**，将处理机分配给它，使之投入运行，直到完成或者因为某种原因而阻塞时才释放处理机。

  + 短作业优先调度算法（SJF）

    SJF从后备队列中选择一个或者若干个估计运行时间最短的作业，将它们调入内存运行。

    SPF从就绪队列中选择一个**估计运行时间最短的进程**，将处理机分配给它，使之立即执行，直到完成或者发生某件事情而阻塞时才释放处理机。

  + 优先级调度算法

    作业调度，每次从后备作业队列中选择优先级最高的一个或者几个作业，将它们调入内存，分配必要的资源，创建进程并且放入就绪队列。

    进程调度，每次从就绪队列中选择**优先级最高的进程**，将处理机分配给它，使之投入运行。

  + 高响应比优先调度算法

    主要用于作业调度，是对**FCFS调度算法和SJF调度算法**的一种综合平衡，同时考虑了每个作业的**等待时间**和**估计运行时间**。从后备作业队列中选择响应比最高的作业投入运行。

    **响应比=（等待时间+要求服务时间）/	要求服务时间**

  + 时间片轮转调度算法

    系统仍然将所有就绪进程按照到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即**先来先服务**的原则，但仅能**运行一个时间片**。在使用完一个时间片时候，即使进程并未完成其运行，它也**必须释放出处理机**给下一个就绪进程，而被剥夺时间片的进程返回到就绪队列的末尾**重新排队**，等候再次运行。

  + 多级反馈队列调度算法（集合了前几中算法的优点）

    **时间片轮转调度算法和优先级调度算法**的综合和发展。



### **进程同步**

+ 进程同步基本概念
  
  在多道程序环境下，进程是并发执行的，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。
  
  + 临界资源
  
    多个进程可以共享系统中的各种资源，但其中许多资源**一次只能为一个进程所使用**，称为**临界资源**。访问临界资源的代码称为**临界区**。
  
  + 同步
  
    同步亦称**直接制约**关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为**需要在某些位置上协调它们的工作次序**而等待、传递信息所产生的制约关系。
  
  + 互斥
  
    互斥亦称**间接制约**关系。当一个进程进入临界区使用临界资源时， 另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。
  
+ 实现临界区互斥的基本方法
  + 软件实现方法
  + 硬件实现方法
  
+ 信号量

  信号量是个整数变量，除了初始化外，它只能通过两个标准原子操作：**wait(S)**和**signal(S)**来访问。这些操作原来被称为**P操作**和**V操作**。wait会判断信号量是否<=0，如果是的话就会阻塞，否则会将信号量减1，而signal操作可以将信号量加1。信号量有两种分别是二进制信号量和计数信号量，二进制信号量的值只能取0和1，计数信号量的值可以是任何整数。

  + 整型信号量
  + 记录型信号量
  + 利用信号量实现同步
  + 利用信号量实现进程互斥
  + 利用信号量实现前趋关系
  + 分析进程同步和互斥问题的方法步骤

+ 管程

  + 管程的定义

    管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的**软件模块**，这组操作能够初始化并改变管程中的数据和同步进程。引入管程是为了**解决信号量机制编程麻烦、易出错的问题**，比如使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

  + 管程的组成

  + 管程的基本特征

    各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据。

    每次仅允许一个进程在管程内执行某个内部过程。

    各进程必须互斥访问管程的特性是由编译器实现的。

    可在管程中设置条件变量及等待/唤醒操作以解决同步问题。

    Java中类似于管程的机制，例如synchronized关键字。

+ 经典同步问题

  + 生产者-消费者问题

    问题描述：系统中一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。

    缓冲区未满，生产者可放入；缓冲区未空，消费者可取出；缓冲区为临界资源，各进程互斥访问。

  + 多生产者-多消费者问题

  + 读者-写者问题

    问题描述：要么多读，要么一写的情况。允许多个读者可以同时对文件执行读操作；只允许一个写者往文件中写信息；任一写者在完成些操作之前不允许其他读者或者写者工作；写者执行写操作前，应让已有的读者和写者全部退出。

    复杂的互斥问题。

  + 哲学家进餐问题

    解决进程死锁。

  + 吸烟者问题
  
    假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料， 供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供 应者一个信号告诉完成了，供应者就会放另外两种材料在桌上，这种过程一直重复（让三个抽烟者轮流地抽烟)。



### **死锁**

+ 什么是死锁

  **各进程互相等待对方手里的资源，导致各进程都阻塞**，无法向前推进。

  死锁、饥饿、死循环的区别：死锁至少是两个进程一起死锁，死锁进程处于阻塞状态。饥饿可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪。死循环可能只有一个进程发生死循环，死循环的进程可上处理机，（有时是程序逻辑的bug导致，有时是程序员故意设计的）。因此死锁和饥饿是操作系统要解决的问题，死循环是程序员要解决的。

+ 死锁产生的条件

  对**不可剥夺资源**的竞争会产生死锁。

  进程在运行过程中，请求和释放资源的**顺序不当**，也会同样导致死锁。

  死锁产生的必要条件：

  1. 互斥：对必须**互斥使用的资源**的争抢才会导致死锁。
  2. 不剥夺：进程保持的资源只能主动释放，**不可强行剥夺**。
  3. 请求保持：**保持**着某些资源不放的同时，**请求**别的资源
  4. 循环等待：存在一种进程资源的**循环等待链**，但是循环等待未必死锁，死锁一定有循环等待的。

+ 如何处理死锁

  + 预防死锁（静态策略）破坏死锁产生的四个必要条件

    **破坏互斥**条件：将临界资源改造成为可共享使用的资源（SPOOLing技术）。但是可行性不高，很多时候无法破坏互斥条件。

    **破坏不剥夺**条件：申请的资源得不到满足时，立即释放拥有的所有资源；申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）。实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿。

    **破坏请求和保持**条件：运行前分配好所需要的资源，之后一直保持。缺点是资源利用率低，而且可能导致饥饿。

    **破坏循环等待**条件：给资源编号，必须按照编号从小到大的顺序申请资源（顺序资源分配法）。但是不方便增加新设备，以及会导致资源浪费，而且用户编程麻烦。

  + 避免死锁（动态策略）

    在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。如**银行家算法**。

    + 安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。
    + 安全状态：只要能找出一个安全序列，系统就是安全状态，**一定不会发生死锁**。如果分配资源之后系统找不出任何一个安全序列，系统就进入了不安全状态，意味着之后可能所有的进程都无法顺利的执行下去。
    + 银行家算法：核心思想是在**资源分配前就预先判断**这次分配是否会导致系统进入**不安全状态**，以此决定是否答应资源分配请求。

  + 死锁检测和解除（允许死锁发生）

    允许死锁发生，系统负责检测出死锁并且解除。

    + 资源剥夺法：**挂起**某些死锁进程，并抢占他的资源，将这些资源分配给其他死锁的进程。但是应该防止被挂起的进程长时间得不到资源而饥饿。
    + 撤销进程法：（终止进程）强制**撤销部分、甚至全部**的死锁进程，并且剥夺这些进程的资源。这种方式的优点是实现简单，但是付出代价可能很大。因为有些进程已经运行很长时间了，可能已经接近结束了，一旦被终止，功亏一篑。
    + 进程回退法：让一个或者多个死锁进程**退回足以避免死锁的地步**。这要求系统要记录进程的历史信息，设置还原点。

    